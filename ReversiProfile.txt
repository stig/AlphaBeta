INTRODUCTION

Timings have been taken for fixed-depth search to various plies from the
initial position in Reversi. There are superficially two sets of
measurements. In the initial ReversiStates were using dynamic arrays to
hold board state internally. The second set changed that to use static
arrays for the state. We expect to see an improvement in the case of
immutable states as there should be a lot less memory movement.

All measurements are taken with a shell loop similar to the following:

    for ply in 3 4 5 ; do
        for mutable in 0 1 ; do
            echo -n "Mutable/ply: $mutable/$ply - "
            /tmp/build/Release/ReversiProfile 100 $ply $mutable | avg
    done ; echo ; done

What waries is the ply and the number of runs to average over (the first
argument to ReversiProfile; 100 in this case).

INITIAL MEASUREMENTS

First I ran some measurements for relatively low plies. I ran 100 of
these, as they take very little time.

    Mutable/ply: 0/3 - avg/stddev/range: 0.039608 0.000666 0.002794
    Mutable/ply: 1/3 - avg/stddev/range: 0.039623 0.000867 0.005181

    Mutable/ply: 0/4 - avg/stddev/range: 0.175492 0.001791 0.008500
    Mutable/ply: 1/4 - avg/stddev/range: 0.173180 0.001130 0.004967

    Mutable/ply: 0/5 - avg/stddev/range: 1.008757 0.026803 0.101017
    Mutable/ply: 1/5 - avg/stddev/range: 0.958873 0.003296 0.013120


The difference at these low plies is negligible. Next up were plies 6 &
7. Each search now start to take a considerable time (especially for 7)
so I limited the count to 10. Still, the difference in results is
basically negligible until ply 7.

    Mutable/ply: 0/6 - avg/stddev/range: 5.839756 0.136928 0.423490
    Mutable/ply: 1/6 - avg/stddev/range: 5.645557 0.018011 0.053170

    Mutable/ply: 0/7 - avg/stddev/range: 42.956067 3.521976 10.496303
    Mutable/ply: 1/7 - avg/stddev/range: 37.355157 0.273884 0.823050

Finally I fired off two runs to ply 8 for each type of state. These
takes serious amount of time for each run.

    Mutable/ply: 0/8 - avg/stddev/range: 318.617202 38.225855 54.059523
    Mutable/ply: 1/8 - avg/stddev/range: 260.696860 0.248446 0.351355

Subsequently a memory leak has found which _could_ be the reason why the
standard deviation is so high in the immutable version above. For the
second run there was a much higher memory pressure than for the first
run; this might have caused it to take more time. More samples would be
needed to answer this question.


SECONDARY MEASUREMENTS

After removing the dynamic arrays used internally, and fixing a memory
leak that caused the program to fail, the following data was gathered.
(As can be seen, the output format of the 'avg' utility has changed.)

    Mutable/ply: 0/7 - count/avg/stddev: 50 36.481652 0.164270
    Mutable/ply: 1/7 - count/avg/stddev: 50 36.845099 0.104681
    
    Mutable/ply: 0/8 - count/avg/stddev: 50 257.880506 0.731970
    Mutable/ply: 1/8 - count/avg/stddev: 50 260.393508 0.744224


DISCUSSION & FUTURE WORK

It is interesting to observe the differences in the standard deviation
of mutable and immutable results in the initial measurements, and how
these disappeared in the secondary ones.

Reducing the amount of dynamic array creation speeded up the immutable
state class, without having any effect on mutable states. Now both types
of states takes about the same time. Immutable states now perform
marginally *better* than mutable ones. This is not completely
unexpected, but it is certainly nice to have it confirmed.

We might want to consider decreasing the maximum boardsize a little, as
this would save memory. Each instance is currently 2k in size (20x20
board of ints takes 1600bytes alone). Setting a max boardsize to 10^2
_could_ get us down to 512, depending on the runtime. Another idea to
try achieving that would be to try to use chars instead of ints.

